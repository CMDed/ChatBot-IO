{
  "respuestas": {
    "saludo": "Hola, soy tu mentor del curso de Lenguajes de Programación. Puedo explicarte sobre los conceptos que abarca la programación funcional, ¿alguna pregunta?",

    "funcion pura": "Una función pura siempre devuelve el mismo resultado si los argumentos son iguales y no causa efectos secundarios.",
    "monada": "Una mónada es una estructura que permite encadenar operaciones con efectos controlados.",
    "io": "En programación funcional, IO representa operaciones de entrada/salida que se controlan de forma segura.",
    "efecto secundario": "Un efecto secundario ocurre cuando una función modifica algo fuera de su ámbito o depende del estado externo.",
    "fallback": "Reformula la respuesta, puedo explicarte sobre funciones puras, mónadas, IO o efectos secundarios.",
    "programacion funcional": "La programación funcional es un paradigma de programación que trata la computación como la evaluación de funciones matemáticas y evita los efectos secundarios y el cambio de estado (mutabilidad)",
    "paradigma": "Un paradigma de programación es un estilo fundamental de desarrollo de software. Los más comunes son el funcional, el imperativo y el orientado a objetos (POO).",
    "poo": "La Programación Orientada a Objetos (POO) es un paradigma basado en el concepto de 'objetos', que pueden contener datos (atributos) y código (métodos). Contrasta con la PF que se basa en funciones puras.",
    "map": "La función Map es una función de orden superior que aplica una función dada a cada elemento de una lista o colección, devolviendo una nueva lista con los resultados sin modificar la original.",
    "filter": "La función Filter es una función de orden superior que evalúa una condición (predicado) en cada elemento de una lista y devuelve una nueva lista que solo contiene los elementos que cumplen esa condición.",
    "reduce": "La función Reduce (o Fold) es una función de orden superior que aplica una función a un acumulador y a cada elemento de una lista para reducir toda la lista a un solo valor (ej. sumar todos los elementos).",
    "inmutabilidad": "La inmutabilidad es la práctica de no cambiar el estado de un objeto una vez que ha sido creado. En lugar de modificarlo, se crea una nueva versión.",
    "composicion de funciones": "La composición de funciones es el acto de combinar funciones simples para construir funciones más complejas, donde la salida de una es la entrada de la siguiente (f(g(x))).",
    "currying": "Currying es una técnica para transformar una función que toma múltiples argumentos en una secuencia de funciones, cada una tomando un solo argumento.",
    "funcion de orden superior": "Una función de orden superior es aquella que toma otras funciones como argumentos, devuelve una función como resultado, o ambas (ejemplo: map, filter, reduce).",
    "aplicacion parcial": "La aplicación parcial es el proceso de fijar algunos argumentos de una función y producir otra función con menos argumentos. Es similar al currying.",
    "transparencia referencial": "La transparencia referencial significa que una expresión puede ser reemplazada por su valor sin cambiar el comportamiento del programa. Es una propiedad clave de las funciones puras.",
    "recursividad": "La recursividad es una técnica donde una función se llama a sí misma para resolver un problema, en lugar de usar bucles.",
    "functor": "Un Functor es una estructura que sabe cómo aplicarle una función a los valores que contiene, manteniendo el contexto (ejemplo: Array, Maybe).",
    "applicative": "Un Applicative es una extensión de Functor que permite aplicar funciones que están envueltas en un contexto a valores envueltos en ese mismo contexto.",
    "lambda": "Una función lambda (o función anónima) es una función definida sin un nombre, que se usa generalmente para pasarse como argumento a funciones de orden superior.",
    "algebraico": "Un tipo de dato algebraico es un tipo de dato compuesto, creado combinando otros tipos. Se dividen en tipos suma (Sum Types) y tipos producto (Product Types).",
    "tipos suma": "Los tipos suma (Sum Types) representan un valor que puede ser *uno u otro* de un conjunto de tipos (ejemplo: 'Éxito' o 'Fallo').",
    "tipos producto": "Los tipos producto (Product Types) representan un valor que contiene *todos* los tipos definidos (ejemplo: una tupla o un registro que contiene varios campos)."
  },

  "respuestas_avanzadas": {
    "funcion pura": "Formalmente, una función pura es un mapeo matemático f: A → B donde la salida depende únicamente de la entrada. No accede ni modifica estado externo, no realiza IO, ni depende del tiempo. Esta propiedad permite razonamiento equacional, optimización, paralelismo seguro y pruebas deterministas.",
    "monada": "Una mónada es un endofunctor M: C → C junto con dos transformaciones naturales: unit (return) y bind (>>=), que deben cumplir las leyes monádicas: identidad izquierda, identidad derecha y asociatividad. En PF permiten encadenar computaciones puras con contexto (estado, IO, errores, listas, etc.) de manera controlada.",
    "io": "En lenguajes funcionales puros como Haskell, IO no es un efecto real, sino una descripción de acciones mediante una mónada. El lenguaje garantiza que estas acciones se encadenen secuencialmente, preservando pureza interna. El intérprete es quien materializa los efectos, no el programador.",
    "efecto secundario": "Un efecto secundario es cualquier interacción observable fuera del retorno de la función: mutación de variables globales, acceso a memoria externa, impresión, lectura del tiempo del sistema o aleatoriedad. Controlarlos mediante mónadas o tipos algebraicos permite mantener predictibilidad y testabilidad.",
    "programacion funcional": "La PF se basa en funciones puras, inmutabilidad, evaluación declarativa y composición. Su fortaleza está en la transparencia referencial, que permite razonamiento formal, paralelismo sin bloqueos y menor probabilidad de errores de estado mutable."
  },

  "reglas": [
    ["\\bfuncion pura\\b", "funcion pura"],
    ["\\bmonada\\b", "monada"],
    ["\\bio\\b", "io"],
    ["\\befecto secundario\\b", "efecto secundario"],
    ["\\b(hola|saludo)\\b", "saludo"],
    ["\\bprogramacion funcional\\b", "programacion funcional"],
    ["\\b(paradigma|paradigmas)\\b", "paradigma"],
    ["\\b(poo|programacion orientada a objetos|orientacion a objetos)\\b", "poo"],
    ["\\bmap\\b", "map"],
    ["\\b(filter|filtrar)\\b", "filter"],
    ["\\b(reduce|reducir|fold)\\b", "reduce"],
    ["\\b(inmutabilidad|inmutable)\\b", "inmutabilidad"],
    ["\\bcomposicion de funciones\\b", "composicion de funciones"],
    ["\\b(currying|curry)\\b", "currying"],
    ["\\bfuncion de orden superior\\b", "funcion de orden superior"],
    ["\\baplicacion parcial\\b", "aplicacion parcial"],
    ["\\btransparencia referencial\\b", "transparencia referencial"],
    ["\\b(recursividad|recursiva)\\b", "recursividad"],
    ["\\b(functor|funtores)\\b", "functor"],
    ["\\b(applicative|aplicativo)\\b", "applicative"],
    ["\\b(lambda|anonima|anonimas)\\b", "lambda"],
    ["\\b(algebraico)\\b", "algebraico"],
    ["\\b(tipos suma|sum types)\\b", "tipos suma"],
    ["\\b(tipos producto|product types)\\b", "tipos producto"]
  ],
  "sinonimos": {
    "funcion": ["funciones", "funcionalidad", "funcionamiento"],
    "pura": ["puras", "puro"],
    "monada": ["monadas", "monad"],
    "io": ["entrada", "salida"],
    "efecto": ["efectos"],
    "secundario": ["secundarios", "colaterales"],
    "saludo": ["saludos"],
    "programacion": ["programacion", "progra"],
    "funcional": ["funcionales", "funcio"],
    "paradigma": ["paradigmas"],
    "poo": ["objetos", "objectos"],
    "map": ["mapear"],
    "filter": ["filtrar"],
    "reduce": ["reducir", "reduccion", "fold", "plegar"],
    "inmutabilidad": ["inmutable", "inmutables", "cambio de estado"],
    "composicion": ["componer", "combinacion", "encadenamiento"],
    "currying": ["curry", "curried"],
    "orden": ["superior", "alto"],
    "aplicacion": ["aplicar"],
    "parcial": ["parciales"],
    "transparencia": ["transparente"],
    "referencial": ["referencia", "referenciales"],
    "recursividad": ["recursiva", "recursivas", "recursion"],
    "functor": ["funtores"],
    "applicative": ["aplicativo", "aplicativos"],
    "lambda": ["anonima", "anonimas"],
    "algebraico": ["algebraicos"],
    "tipos": ["tipo"],
    "suma": ["sum"],
    "producto": ["product"]
  }
}